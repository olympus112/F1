<!DOCTYPE html>
<html lang = "en">
    <head>
        <meta charset="utf-8">
        <title>Details</title>
        <script type="text/javascript" src="https://d3js.org/d3.v4.min.js"></script>
    </head>

    <div id="graph">
    </div>

    <script>
        var parseDate = d3.timeParse('%d/%m/%Y');
        // set the dimensions and margins of the graph
        var margin = {top: 10, right: 100, bottom: 60, left: 60},
            width = 460 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;

        

            // append the svg object to the body of the page
        var svg = d3.select("#graph")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");



        // showRaceConsistency(822, 2021);
        showTimeConsistency(1, 2021);
        // test();



        function showRaceConsistency(driverId, year) {

            d3.csv("../data/races.csv", function(races){ 
                    d3.csv("../data/results.csv", function(results){
                        races = races.filter(function(row) {
                            return row.year == year;
                        });
                        var maxRaceId = Math.max.apply(Math, races.map(function(race) { return race.raceId; }));
                        var minRaceId = Math.min.apply(Math, races.map(function(race) { return race.raceId; }));
                        results = results.filter(function(row){
                            return row.driverId == driverId && row.raceId >= minRaceId && row.raceId <= maxRaceId;
                        });
                        var data = [];
                        races.forEach(race => {
                            var found = false;
                            var date = parseDate(race.date);
                            date = new Date(race.year, date.getMonth(), date.getDate());
                            results.forEach(result => {
                                if (race.raceId == result.raceId){
                                    found=true;
                                    if (result.position == '\\N'){
                                        data.push({date: date, value: "20"})
                                    }
                                    else 
                                        data.push({date: date, value: result.position})
                                }
                            }); 
                            if (!found){  
                                data.push({date: date, value: "20"})
                            }
                        });

                        data = data.sort((a, b) => (a.date > b.date) ? 1 : -1)
                    



                        // Add X axis --> it is a date format
                        var x = d3.scaleTime()
                        .domain(d3.extent(data, function(d) { return d.date; }))
                        .range([ 0, width ]);
                        svg.append("g")
                        .attr("transform", "translate(0," + height + ")")
                        .call(d3.axisBottom(x))
                        .selectAll("text")	
                            .style("text-anchor", "end")
                            .attr("dx", "-.8em")
                            .attr("dy", ".15em")
                            .attr("transform", function(d) {
                                return "rotate(-65)" 
                                });

                        // Add Y axis
                        var y = d3.scaleLinear()
                        .domain([0, 20])
                        .range([ height, 0 ]);
                        svg.append("g")
                        .call(d3.axisLeft(y))

                        //calculate leastSquares
                        var lsm = leastSquareMethod(data);
                        var lsmPoints = lsm.lsmPoints;

                        var indexies = d3.range( data.length );
                        var area = d3.area()
                                        .x( function(d) { return x(data[d].date.getTime())} )
                                        // .x1(function(d) {return d})
                                        .y1( function(d) { return  y(data[d].value) } )
                                        .y0(  function(d) { return y(lsmPoints[d].value) } );
                        svg.append('path')
                        .datum(indexies)
                        .attr('class', 'area')
                        .attr('fill', 'red')
                        .attr('d', area);

                        // Add the line
                        svg.append("path")
                        .datum(data)
                        .attr("fill", "none")
                        .attr("stroke", "black")
                        .attr("stroke-width", 1.5)
                        .attr("d", d3.line()
                            .x(function(d) { return x(d.date) })
                            .y(function(d) { return y(d.value) })
                            )

                        svg.append("path")
                        .datum(lsmPoints)
                        .attr("fill", "none")
                        .attr("stroke", "black")
                        .attr("stroke-width", 3)
                        .attr("d", d3.line()
                            .x(function(d) { return x(d.date) })
                            .y(function(d) { return y(d.value) })
                            )
                            
                        console.log("graph finished");
                    });
            });



        }

        function leastSquareMethod(data){
            var n = data.length
            var sumXY = 0;
            var sumX = 0;
            var sumY = 0;
            var sumXSquared = 0;
            data.forEach(element => {
                var date  = element.date.getTime();
                var value = parseInt(element.value);
                sumXY += date*value;
                sumX += date;
                sumY += value;
                sumXSquared += date * date;
            });

            var b = (n*sumXY -sumX*sumY) / (n*sumXSquared - sumX*sumX);
            var a = sumY/n - b * sumX/n;

            var lsm = [];
            var sqDiff = 0;
            data.forEach(element => {
                var x = element.date;
                var y = a + b*x;
                lsm.push({value: y, date: x});
                sqDiff += Math.pow((element.value - y), 2);
            });
            var avgDiff = Math.sqrt(sqDiff/data.length);
            console.log("average difference: ", avgDiff);
            return {lsmPoints: lsm, avgDiff: avgDiff};
        }


        function showTimeConsistency(driverId, year){
            d3.csv("../data/races.csv", function(races){ 
                    d3.csv("../data/lap_times.csv", function(lapTimes){
                        races = races.filter(function(row) {
                            return row.year == year;
                        });
                        var maxRaceId = Math.max.apply(Math, races.map(function(race) { return race.raceId; }));
                        var minRaceId = Math.min.apply(Math, races.map(function(race) { return race.raceId; }));
                        //filter out useless laptimes
                        lapTimes = lapTimes.filter(function(row){
                            return row.driverId == driverId && row.raceId >= minRaceId && row.raceId <= maxRaceId;
                        });
                        var data = [];
                        races.forEach(race => {
                            
                            var date = parseDate(race.date);
                            date = new Date(race.year, date.getMonth(), date.getDate());

                            var raceLaptimes = lapTimes.filter(function(row){
                                return row.raceId == race.raceId;
                            });

                            var unfilteredMean = 0;
                            var unfilteredN = 0;
                            var filterVariance = 1.5;
                            //calculate Mean of unfiltered lap times (including safety car, pitstop,...)
                            raceLaptimes.forEach(lapTime => {
                                unfilteredMean += parseInt(lapTime.milliseconds);
                                unfilteredN++;
                            });
                            unfilteredMean = unfilteredMean / unfilteredN;


                            //list containing only the racetimes in milliseconds, nothing else
                            //Filtering applied
                            var times = [];
                            raceLaptimes.forEach(lapTime => {
                                var t = parseInt(lapTime.milliseconds);
                                if (t <= filterVariance * unfilteredMean){
                                    times.push(t);
                                }
                            });
                            
                            if (times.length != 0){
                                var mean = 0;
                                var n = 0;
                                // calculate avarage and deviation
                                times.forEach(time => {
                                    mean += time;
                                    n++;
                                });
                                mean = mean / n;

                                //sum of difference between values and mean squared
                                var diffMean = 0;
                                times.forEach(time => {
                                    diffMean += Math.pow(Math.abs(time - mean), 2);
                                });

                                var sd = Math.sqrt(diffMean/n);
                                data.push({date: date, value: sd})
                            }
                        });

                        data = data.sort((a, b) => (a.date > b.date) ? 1 : -1);
                    



                        // Add X axis --> it is a date format
                        var x = d3.scaleTime()
                        .domain(d3.extent(data, function(d) { return d.date; }))
                        .range([ 0, width ]);
                        svg.append("g")
                        .attr("transform", "translate(0," + height + ")")
                        .call(d3.axisBottom(x))
                        .selectAll("text")	
                            .style("text-anchor", "end")
                            .attr("dx", "-.8em")
                            .attr("dy", ".15em")
                            .attr("transform", function(d) {
                                return "rotate(-65)" 
                                });

                        // Add Y axis
                        var y = d3.scaleLinear()
                        .domain(d3.extent(data, function(d) { return d.value; }))
                        .range([ height, 0 ]);
                        svg.append("g")
                        .call(d3.axisLeft(y))

                        //calculate leastSquares
                        var lsm = leastSquareMethod(data);
                        var lsmPoints = lsm.lsmPoints;

                        var indexies = d3.range( data.length );
                        var area = d3.area()
                                        .x( function(d) { return x(data[d].date.getTime())} )
                                        // .x1(function(d) {return d})
                                        .y1( function(d) { return  y(data[d].value) } )
                                        .y0(  function(d) { return y(lsmPoints[d].value) } );
                        svg.append('path')
                        .datum(indexies)
                        .attr('class', 'area')
                        .attr('fill', 'red')
                        .attr('d', area);

                        // Add the line
                        svg.append("path")
                        .datum(data)
                        .attr("fill", "none")
                        .attr("stroke", "black")
                        .attr("stroke-width", 1.5)
                        .attr("d", d3.line()
                            .x(function(d) { return x(d.date) })
                            .y(function(d) { return y(d.value) })
                            )

                        svg.append("path")
                        .datum(lsmPoints)
                        .attr("fill", "none")
                        .attr("stroke", "black")
                        .attr("stroke-width", 3)
                        .attr("d", d3.line()
                            .x(function(d) { return x(d.date) })
                            .y(function(d) { return y(d.value) })
                            )
                            
                        console.log("graph finished");
                    });
            });




        function calculateDeviationLapTimes(callBack){

        }
        }




    </script>
</html>